<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux系统编程 | 时光屋</title><meta name="keywords" content="系统编程"><meta name="author" content="呆小呆"><meta name="copyright" content="呆小呆"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux系统编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程">
<meta property="og:url" content="http://example.com/2022/08/29/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="时光屋">
<meta property="og:description" content="Linux系统编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Cbase.jpeg">
<meta property="article:published_time" content="2022-08-29T11:22:03.000Z">
<meta property="article:modified_time" content="2022-08-29T11:36:59.790Z">
<meta property="article:author" content="呆小呆">
<meta property="article:tag" content="系统编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Cbase.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/08/29/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux系统编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-29 19:36:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 外链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../img/Cbase.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">时光屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 外链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux系统编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-29T11:22:03.000Z" title="发表于 2022-08-29 19:22:03">2022-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-29T11:36:59.790Z" title="更新于 2022-08-29 19:36:59">2022-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux系统编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>Linux系统： “所见皆文件”</p>
<p>Linux系统目录：</p>
<pre><code>bin：存放二进制可执行文件
boot：存放开机启动程序
dev：存放设备文件： 字符设备、块设备
home：存放普通用户
etc：用户信息和系统配置文件 passwd、group
lib：库文件：libc.so.6
root：管理员宿主目录（家目录）
usr：用户资源管理目录
</code></pre>
<p>Linux系统文件类型： 7&#x2F;8 种</p>
<pre><code>普通文件：-
目录文件：d
字符设备文件：c
块设备文件：b
软连接：l
管道文件：p
套接字：s
未知文件。
</code></pre>
<p>软连接：快捷方式</p>
<pre><code>为保证软连接可以任意搬移， 创建时务必对源文件使用 绝对路径。
</code></pre>
<p>硬链接：</p>
<pre><code>ln file  file.hard

操作系统给每一个文件赋予唯一的 inode，当有相同inode的文件存在时，彼此同步。

删除时，只将硬链接计数减一。减为0时，inode 被释放。
</code></pre>
<p>创建用户：</p>
<pre><code>sudo adduser 新用户名		--- useradd
</code></pre>
<p>修改文件所属用户：</p>
<pre><code>sudo chown 新用户名 待修改文件。

sudo chown wangwu a.c
</code></pre>
<p>删除用户：<br>    sudo deluser 用户名</p>
<p>创建用户组：<br>    sudo addgroup 新组名</p>
<p>修改文件所属用户组：</p>
<pre><code>sudo chgrp 新用户组名 待修改文件。

sudo chgrp g88 a.c
</code></pre>
<p>删除组：<br>    sudo delgroup 用户组名</p>
<p>使用chown 一次修改所有者和所属组：</p>
<pre><code>sudo chown 所有者：所属组  待操作文件。
</code></pre>
<p>find命令：找文件</p>
<pre><code>-type 按文件类型搜索  d/p/s/c/b/l/ f:文件

-name 按文件名搜索

    find ./ -name &quot;*file*.jpg&quot;

-maxdepth 指定搜索深度。应作为第一个参数出现。

    find ./ -maxdepth 1 -name &quot;*file*.jpg&quot;


-size 按文件大小搜索. 单位：k、M、G

    find /home/itcast -size +20M -size -50M

-atime、mtime、ctime 天  amin、mmin、cmin 分钟。

-exec：将find搜索的结果集执行某一指定命令。

    find /usr/ -name &#39;*tmp*&#39; -exec ls -ld &#123;&#125; \;

-ok: 以交互式的方式 将find搜索的结果集执行某一指定命令


-xargs：将find搜索的结果集执行某一指定命令。  当结果集数量过大时，可以分片映射。

    find /usr/ -name &#39;*tmp*&#39; | xargs ls -ld 

-print0：
    find /usr/ -name &#39;*tmp*&#39; -print0 | xargs  -0 ls -ld 
</code></pre>
<p>grep命令：找文件内容</p>
<pre><code>grep -r &#39;copy&#39; ./ -n

    -n参数：:显示行号

ps aux | grep &#39;cupsd&#39;  -- 检索进程结果集。
</code></pre>
<p>软件安装：</p>
<pre><code>1. 联网

2. 更新软件资源列表到本地。  sudo apt-get update

3. 安装 sudo apt-get install 软件名

4. 卸载	sudo apt-get remove 软件名

5. 使用软件包（.deb） 安装：	sudo dpkg -i 安装包名。
</code></pre>
<p>tar压缩：</p>
<pre><code>1. tar -zcvf 要生成的压缩包名	压缩材料。

    tar zcvf  test.tar.gz  file1 dir2   使用 gzip方式压缩。

    tar jcvf  test.tar.gz  file1 dir2   使用 bzip2方式压缩。
</code></pre>
<p>tar解压：</p>
<pre><code>将 压缩命令中的 c --&gt; x

    tar zxvf  test.tar.gz   使用 gzip方式解压缩。

    tar jxvf  test.tar.gz   使用 bzip2方式解压缩。
</code></pre>
<p>rar压缩：</p>
<pre><code>rar a -r  压缩包名（带.rar后缀） 压缩材料。

    rar a -r testrar.rar	stdio.h test2.mp3
</code></pre>
<p>rar解压：</p>
<pre><code>unrar x 压缩包名（带.rar后缀）
</code></pre>
<p>zip压缩：</p>
<pre><code>zip -r 压缩包名（带.zip后缀） 压缩材料。

    zip -r testzip.zip dir stdio.h test2.mp3
</code></pre>
<p>zip解压：<br>    unzip 压缩包名（带.zip后缀） </p>
<pre><code>    unzip  testzip.zip 
</code></pre>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>跳转到指定行：</p>
<pre><code>1. 88G （命令模式）

2. :88  (末行模式)
</code></pre>
<p>跳转文件首：</p>
<pre><code>gg （命令模式）
</code></pre>
<p>跳转文件尾：</p>
<pre><code>G（命令模式）
</code></pre>
<p>自动格式化程序：</p>
<pre><code>gg=G（命令模式）
</code></pre>
<p>大括号对应：</p>
<pre><code>% （命令模式）
</code></pre>
<p>光标移至行首：</p>
<pre><code>0 （命令模式）执行结束，工作模式不变。
</code></pre>
<p>光标移至行尾：</p>
<pre><code>$ （命令模式）执行结束，工作模式不变。
</code></pre>
<p>删除单个字符：</p>
<pre><code>x （命令模式）执行结束，工作模式不变。
</code></pre>
<p>替换单个字符：</p>
<pre><code>将待替换的字符用光标选中， r （命令模式），再按欲替换的字符
</code></pre>
<p>删除一个单词：</p>
<pre><code>dw（命令模式）光标置于单词的首字母进行操作。
</code></pre>
<p>删除光标至行尾：</p>
<pre><code>D 或者 d$（命令模式）
</code></pre>
<p>删除光标至行首：</p>
<pre><code>d0 （命令模式）
</code></pre>
<p>删除指定区域：</p>
<pre><code>按 V （命令模式）切换为 “可视模式”，使用 hjkl挪移光标来选中待删除区域。  按 d 删除该区域数据。
</code></pre>
<p>删除指定1行：</p>
<pre><code>在光标所在行，按 dd （命令模式）
</code></pre>
<p>删除指定N行：</p>
<pre><code>在光标所待删除首行，按 Ndd （命令模式）
</code></pre>
<p>复制一行：</p>
<pre><code>yy
</code></pre>
<p>粘贴：<br>    p：向后、P：向前。</p>
<p>查找：<br>    1. 找 设想 内容：</p>
<pre><code>    命令模式下， 按 “/” 输入欲搜索关键字，回车。使用 n 检索下一个。

2. 找 看到的内容：

    命令模式下，将光标置于单词任意一个字符上，按 “*”/ “#” 
</code></pre>
<p>单行替换：</p>
<pre><code>将光标置于待替换行上， 进入末行模式，输入 :s /原数据/新数据
</code></pre>
<p>通篇替换：</p>
<pre><code>末行模式， :%s /原数据/新数据/g   g:不加，只替换每行首个。   sed 
</code></pre>
<p>指定行的替换：</p>
<pre><code>末行模式， :起始行号，终止行号s /原数据/新数据/g   g:不加，只替换每行首个。

    :29,35s /printf/println/g
</code></pre>
<p>撤销、反撤销：</p>
<pre><code>u、ctrl+r（命令模式）
</code></pre>
<p>分屏：<br>    sp：横屏分。 Ctrl+ww 切换。</p>
<pre><code>vsp：竖屏分。Ctrl+ww 切换。
</code></pre>
<p>跳转至 man 手册：</p>
<pre><code>将光标置于待查看函数单词上，使用 K（命令模式）跳转。 指定卷， nK
</code></pre>
<p>查看宏定义：</p>
<pre><code>将光标置于待查看宏定义单词上，使用 [d 查看定义语句。
</code></pre>
<p>在末行模式执行shell命令：</p>
<pre><code>:!命令		:! ls -l 
</code></pre>
<hr>
<p>gcc编译：</p>
<pre><code>4步骤： 预处理、编译、汇编、连接。

-I：	指定头文件所在目录位置。

-c：	只做预处理、编译、汇编。得到 二进制 文件！！！

-g：	编译时添加调试语句。 主要支持 gdb 调试。

-Wall： 显示所有警告信息。

-D：	向程序中“动态”注册宏定义。   #define NAME VALUE
</code></pre>
<p>静态库制作及使用步骤：</p>
<pre><code>1. 将 .c 生成 .o 文件

    gcc -c add.c -o add.o

2. 使用 ar 工具制作静态库

    ar rcs  lib库名.a  add.o sub.o div.o

3. 编译静态库到可执行文件中：

    gcc test.c lib库名.a -o a.out
</code></pre>
<p>头文件守卫：防止头文件被重复包含</p>
<pre><code>#ifndef _HEAD_H_

#define _HEAD_H_

......

#endif
</code></pre>
<p>动态库制作及使用：</p>
<pre><code>1.  将 .c 生成 .o 文件， （生成与位置无关的代码 -fPIC）

    gcc -c add.c -o add.o -fPIC

2. 使用 gcc -shared 制作动态库

    gcc -shared -o lib库名.so	add.o sub.o div.o

3. 编译可执行程序时，指定所使用的动态库。  -l：指定库名(去掉lib前缀和.so后缀)  -L：指定库路径。

    gcc test.c -o a.out -lmymath -L./lib

4. 运行可以执行程序 ./a.out 出错！！！！ --- ldd a.out --&gt; &quot;not found&quot;

    error while loading shared libraries: libxxx.so: cannot open shared object file: No such file or directory

    原因：
        链接器：	工作于链接阶段， 工作时需要 -l 和 -L

        动态链接器：	工作于程序运行阶段，工作时需要提供动态库所在目录位置。

    解决方式：				

        【1】 通过环境变量：  export LD_LIBRARY_PATH=动态库路径

            ./a.out 成功！！！  （临时生效， 终端重启环境变量失效）

        【2】 永久生效： 写入 终端配置文件。  .bashrc  建议使用绝对路径。

            1) vi ~/.bashrc

            2) 写入 export LD_LIBRARY_PATH=动态库路径  保存

            3）. .bashrc/  source .bashrc / 重启 终端  ---&gt; 让修改后的.bashrc生效

            4）./a.out 成功！！！ 

        【3】 拷贝自定义动态库 到 /lib (标准C库所在目录位置)

        【4】 配置文件法

            1）sudo vi /etc/ld.so.conf

            2) 写入 动态库绝对路径  保存

            3）sudo ldconfig -v  使配置文件生效。

            4）./a.out 成功！！！--- 使用 ldd  a.out 查看
</code></pre>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>gdb调试工具：   大前提：程序是你自己写的。  —逻辑错误</p>
<p>基础指令：<br>    -g：使用该参数编译可以执行文件，得到调试表。</p>
<pre><code>gdb ./a.out

list： list 1  列出源码。根据源码指定 行号设置断点。

b：	b 20	在20行位置设置断点。

run/r:	运行程序

n/next: 下一条指令（会越过函数）

s/step: 下一条指令（会进入函数）

p/print：p i  查看变量的值。

continue：继续执行断点后续指令。

finish：结束当前函数调用。 

quit：退出gdb当前调试。
</code></pre>
<p>其他指令：</p>
<pre><code>run：使用run查找段错误出现位置。

set args： 设置main函数命令行参数 （在 start、run 之前）

run 字串1 字串2 ...: 设置main函数命令行参数

info b: 查看断点信息表

b 20 if i = 5：	设置条件断点。

ptype：查看变量类型。

bt：列出当前程序正存活着的栈帧。

frame： 根据栈帧编号，切换栈帧。

display：设置跟踪变量

undisplay：取消设置跟踪变量。 使用跟踪变量的编号。
</code></pre>
<p>makefile： 管理项目。</p>
<pre><code>命名：makefile	 Makefile  --- make 命令

1 个规则：

    目标：依赖条件
    （一个tab缩进）命令

    1. 目标的时间必须晚于依赖条件的时间，否则，更新目标

    2. 依赖条件如果不存在，找寻新的规则去产生依赖条件。

ALL：指定 makefile 的终极目标。


2 个函数：

    src = $(wildcard ./*.c): 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src。  src = add.c sub.c div1.c 

    obj = $(patsubst %.c, %.o, $(src)): 将参数3中，包含参数1的部分，替换为参数2。 obj = add.o sub.o div1.o

clean:	(没有依赖)

    -rm -rf $(obj) a.out	“-”：作用是，删除不存在文件时，不报错。顺序执行结束。

3 个自动变量：

    $@: 在规则的命令中，表示规则中的目标。

    $^: 在规则的命令中，表示所有依赖条件。

    $&lt;: 在规则的命令中，表示第一个依赖条件。如果将该变量应用在模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。

模式规则：

    %.o:%.c
       gcc -c $&lt; -o %@

静态模式规则：

    $(obj):%.o:%.c
       gcc -c $&lt; -o %@	

伪目标：

    .PHONY: clean ALL

参数：
    -n：模拟执行make、make clean 命令。

    -f：指定文件执行 make 命令。				xxxx.mk


作业：编写一个 makefile 可以将其所在目录下的所有独立 .c 文件编译生成同名可执行文件。
</code></pre>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>open函数：</p>
<pre><code>int open(char *pathname, int flags)	#include &lt;unistd.h&gt;

参数：
    pathname: 欲打开的文件路径名

    flags：文件打开方式：	#include &lt;fcntl.h&gt;

        O_RDONLY|O_WRONLY|O_RDWR	O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ....

返回值：
    成功： 打开文件所得到对应的 文件描述符（整数）

    失败： -1， 设置errno	

int open(char *pathname, int flags， mode_t mode)		123  775	

参数：
    pathname: 欲打开的文件路径名

    flags：文件打开方式：	O_RDONLY|O_WRONLY|O_RDWR	O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK ....

    mode: 参数3使用的前提， 参2指定了 O_CREAT。	取值8进制数，用来描述文件的 访问权限。 rwx    0664

        创建文件最终权限 = mode &amp; ~umask

返回值：
    成功： 打开文件所得到对应的 文件描述符（整数）

    失败： -1， 设置errno	
</code></pre>
<p>close函数：</p>
<pre><code>int close(int fd);
</code></pre>
<p>错误处理函数：		与 errno 相关。</p>
<pre><code>printf(&quot;xxx error: %d\n&quot;, errno);

char *strerror(int errnum);

    printf(&quot;xxx error: %s\n&quot;, strerror(errno));

void perror(const char *s);

    perror(&quot;open error&quot;);
</code></pre>
<p>read函数：</p>
<pre><code>ssize_t read(int fd, void *buf, size_t count);

参数：
    fd：文件描述符

    buf：存数据的缓冲区

    count：缓冲区大小

返回值：

    0：读到文件末尾。

    成功；	&gt; 0 读到的字节数。

    失败：	-1， 设置 errno

    -1： 并且 errno = EAGIN 或 EWOULDBLOCK, 说明不是read失败，而是read在以非阻塞方式读一个设备文件（网络文件），并且文件无数据。
</code></pre>
<p>write函数：</p>
<pre><code>ssize_t write(int fd, const void *buf, size_t count);

参数：
    fd：文件描述符

    buf：待写出数据的缓冲区

    count：数据大小

返回值：

    成功；	写入的字节数。

    失败：	-1， 设置 errno
</code></pre>
<p>文件描述符：</p>
<pre><code>PCB进程控制块：本质 结构体。

成员：文件描述符表。

文件描述符：0/1/2/3/4。。。。/1023     表中可用的最小的。

0 - STDIN_FILENO

1 - STDOUT_FILENO

2 - STDERR_FILENO
</code></pre>
<p>阻塞、非阻塞：  是设备文件、网络文件的属性。</p>
<pre><code>产生阻塞的场景。 读设备文件。读网络文件。（读常规文件无阻塞概念。）

/dev/tty -- 终端文件。

open(&quot;/dev/tty&quot;, O_RDWR|O_NONBLOCK)	--- 设置 /dev/tty 非阻塞状态。(默认为阻塞状态)
</code></pre>
<p>fcntl：<br>    int (int fd, int cmd, …)</p>
<pre><code>int flgs = fcntl(fd,  F_GETFL);

flgs |= O_NONBLOCK

fcntl(fd,  F_SETFL, flgs);

获取文件状态： F_GETFL

设置文件状态： F_SETFL
</code></pre>
<p>lseek函数：</p>
<pre><code>off_t lseek(int fd, off_t offset, int whence);

参数：
    fd：文件描述符

    offset： 偏移量

    whence：起始偏移位置： SEEK_SET/SEEK_CUR/SEEK_END

返回值：

    成功：较起始位置偏移量

    失败：-1 errno

应用场景：	
    1. 文件的“读”、“写”使用同一偏移位置。

    2. 使用lseek获取文件大小

    3. 使用lseek拓展文件大小：要想使文件大小真正拓展，必须引起IO操作。

        使用 truncate 函数，直接拓展文件。	int ret = truncate(&quot;dict.cp&quot;, 250);
</code></pre>
<p>传入参数：</p>
<pre><code>1. 指针作为函数参数。

2. 同常有const关键字修饰。

3. 指针指向有效区域， 在函数内部做读操作。
</code></pre>
<p>传出参数：</p>
<pre><code>1. 指针作为函数参数。

2. 在函数调用之前，指针指向的空间可以无意义，但必须有效。

3. 在函数内部，做写操作。

4。函数调用结束后，充当函数返回值。
</code></pre>
<p>传入传出参数：</p>
<pre><code>1. 指针作为函数参数。

2. 在函数调用之前，指针指向的空间有实际意义。

3. 在函数内部，先做读操作，后做写操作。

4. 函数调用结束后，充当函数返回值。
</code></pre>
<p> void aaa();</p>
<p> int aaa(int *p, struct stat *p2, strcut student *p3);</p>
<p> bbb()<br> {<br>    aaa();<br> }</p>
<p>stat&#x2F;lstat 函数：</p>
<pre><code>int stat(const char *path, struct stat *buf);

参数：
    path： 文件路径

    buf：（传出参数） 存放文件属性。

返回值：

    成功： 0

    失败： -1 errno

获取文件大小： buf.st_size

获取文件类型： buf.st_mode

获取文件权限： buf.st_mode

符号穿透：stat会。lstat不会。
</code></pre>
<p>link&#x2F;unlink:</p>
<pre><code>隐式回收。
</code></pre>
<p>目录操作函数：</p>
<pre><code>DIR * opendir(char *name);

int closedir(DIR *dp);

struct dirent *readdir(DIR * dp);

    struct dirent &#123;

        inode

        char dname[256];
    &#125;
</code></pre>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><pre><code>./a.out ls.c  /home/itcast/28_Linux  ./abc/

        /home/itcast/28_Linux/testdir/
</code></pre>
<p>递归遍历目录：ls-R.c</p>
<pre><code>1. 判断命令行参数，获取用户要查询的目录名。	int argc, char *argv[1]

    argc == 1  --&gt; ./

2. 判断用户指定的是否是目录。 stat  S_ISDIR(); --&gt; 封装函数 isFile() &#123;   &#125;

3. 读目录： read_dir() &#123; 

    opendir（dir）

    while （readdir（））&#123;

        普通文件，直接打印

        目录：
            拼接目录访问绝对路径。sprintf(path, &quot;%s/%s&quot;, dir, d_name) 

            递归调用自己。--》 opendir（path） readdir closedir
    &#125;

    closedir（）

    &#125;
    read_dir() --&gt; isFile() ---&gt; read_dir()
</code></pre>
<p>dup 和 dup2：</p>
<pre><code>int dup(int oldfd);		文件描述符复制。

    oldfd: 已有文件描述符

    返回：新文件描述符。

int dup2(int oldfd, int newfd); 文件描述符复制。重定向。
</code></pre>
<p>fcntl 函数实现 dup：</p>
<pre><code>int fcntl(int fd, int cmd, ....)

cmd: F_DUPFD

参3:  	被占用的，返回最小可用的。

    未被占用的， 返回=该值的文件描述符。
</code></pre>
<p>进程：<br>    程序：死的。只占用磁盘空间。		——剧本。</p>
<pre><code>进程；活的。运行起来的程序。占用内存、cpu等系统资源。	——戏。
</code></pre>
<p>PCB进程控制块：</p>
<pre><code>进程id

文件描述符表

进程状态：	初始态、就绪态、运行态、挂起态、终止态。

进程工作目录位置

*umask掩码 

信号相关信息资源。

用户id和组id
</code></pre>
<p>fork函数：</p>
<pre><code>pid_t fork(void)

创建子进程。父子进程各自返回。父进程返回子进程pid。 子进程返回 0.

getpid();getppid();

循环创建N个子进程模型。 每个子进程标识自己的身份。
</code></pre>
<p>父子进程相同：</p>
<pre><code>刚fork后。 data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式
</code></pre>
<p>父子进程不同：</p>
<pre><code>进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集
</code></pre>
<p>父子进程共享：</p>
<pre><code>读时共享、写时复制。———————— 全局变量。

1. 文件描述符 2. mmap映射区。
</code></pre>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>gdb调试：</p>
<pre><code>设置父进程调试路径：set follow-fork-mode parent (默认)

设置子进程调试路径：set follow-fork-mode child
</code></pre>
<p>exec函数族：</p>
<pre><code>使进程执行某一程序。成功无返回值，失败返回 -1

int execlp(const char *file, const char *arg, ...);		借助 PATH 环境变量找寻待执行程序

    参1： 程序名

    参2： argv0

    参3： argv1

    ...： argvN

    哨兵：NULL

int execl(const char *path, const char *arg, ...);		自己指定待执行程序路径。

int execvp();
</code></pre>
<p>ps ajx –&gt; pid ppid gid sid </p>
<p>孤儿进程：</p>
<pre><code>父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程领养。
</code></pre>
<p>僵尸进程：</p>
<pre><code>子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。  kill 对其无效。
</code></pre>
<p>wait函数：	回收子进程退出资源， 阻塞回收任意一个。</p>
<pre><code>pid_t wait(int *status)

参数：（传出） 回收进程的状态。

返回值：成功： 回收进程的pid

    失败： -1， errno

函数作用1：	阻塞等待子进程退出

函数作用2：	清理子进程残留在内核的 pcb 资源

函数作用3：	通过传出参数，得到子进程结束状态
</code></pre>
<p>​	<br>​	获取子进程正常终止值：<br>​	<br>        WIFEXITED(status) –》 为真 –》调用 WEXITSTATUS(status) –》 得到 子进程 退出值。</p>
<pre><code>获取导致子进程异常终止信号：

    WIFSIGNALED(status) --》 为真 --》调用 WTERMSIG(status) --》 得到 导致子进程异常终止的信号编号。
</code></pre>
<p>waitpid函数：	指定某一个进程进行回收。可以设置非阻塞。			waitpid(-1, &amp;status, 0) &#x3D;&#x3D; wait(&amp;status);</p>
<pre><code>pid_t waitpid(pid_t pid, int *status, int options)

参数：
    pid：指定回收某一个子进程pid

        &gt; 0: 待回收的子进程pid

        -1：任意子进程

        0：同组的子进程。

    status：（传出） 回收进程的状态。

    options：WNOHANG 指定回收方式为，非阻塞。

返回值：

    &gt; 0 : 表成功回收的子进程 pid

    0 : 函数调用时， 参3 指定了WNOHANG， 并且，没有子进程结束。

    -1: 失败。errno
</code></pre>
<p>总结：</p>
<pre><code>wait、waitpid	一次调用，回收一个子进程。

        想回收多个。while 
</code></pre>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>进程间通信的常用方式，特征：</p>
<pre><code>管道：简单

信号：开销小

mmap映射：非血缘关系进程间

socket（本地套接字）：稳定
</code></pre>
<p>管道：</p>
<pre><code>实现原理： 内核借助环形队列机制，使用内核缓冲区实现。

特质；	1. 伪文件

    2. 管道中的数据只能一次读取。

    3. 数据在管道中，只能单向流动。

局限性：1. 自己写，不能自己读。

    2. 数据不可以反复读。

    3. 半双工通信。

    4. 血缘关系进程间可用。
</code></pre>
<p>pipe函数：	创建，并打开管道。</p>
<pre><code>int pipe(int fd[2]);

参数：	fd[0]: 读端。

    fd[1]: 写端。

返回值： 成功： 0

     失败： -1 errno
</code></pre>
<p>管道的读写行为：</p>
<pre><code>读管道：
    1. 管道有数据，read返回实际读到的字节数。

    2. 管道无数据：	1）无写端，read返回0 （类似读到文件尾）

            2）有写端，read阻塞等待。

写管道：
    1. 无读端， 异常终止。 （SIGPIPE导致的）

    2. 有读端：	1） 管道已满， 阻塞等待

            2） 管道未满， 返回写出的字节个数。
</code></pre>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p>pipe管道： 用于有血缘关系的进程间通信。  ps aux | grep 		ls | wc -l	</p>
<pre><code>父子进程间通信：


兄弟进程间通信：
</code></pre>
<p>fifo管道：可以用于无血缘关系的进程间通信。</p>
<pre><code>命名管道：  mkfifo 

无血缘关系进程间通信：

    读端，open fifo O_RDONLY

    写端，open fifo O_WRONLY
</code></pre>
<p>文件实现进程间通信：</p>
<pre><code>打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。
</code></pre>
<p>共享内存映射:</p>
<p>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);		创建共享内存映射</p>
<pre><code>参数：
    addr： 	指定映射区的首地址。通常传NULL，表示让系统自动分配

    length：共享内存映射区的大小。（&lt;= 文件的实际大小）

    prot：	共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE

    flags：	标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE

    fd:	用于创建共享内存映射区的那个文件的 文件描述符。

    offset：默认0，表示映射文件全部。偏移位置。需是 4k 的整数倍。

返回值：

    成功：映射区的首地址。

    失败：MAP_FAILED (void*(-1))， errno
</code></pre>
<p>int munmap(void *addr, size_t length);		释放映射区。</p>
<pre><code>addr：mmap 的返回值

length：大小
</code></pre>
<p>使用注意事项：</p>
<pre><code>1. 用于创建映射区的文件大小为 0，实际指定非0大小创建映射区，出 “总线错误”。

2. 用于创建映射区的文件大小为 0，实际制定0大小创建映射区， 出 “无效参数”。

3. 用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。

4. 创建映射区，需要read权限。当访问权限指定为 “共享”MAP_SHARED是， mmap的读写权限，应该 &lt;=文件的open权限。	只写不行。

5. 文件描述符fd，在mmap创建映射区完成即可关闭。后续访问文件，用 地址访问。

6. offset 必须是 4096的整数倍。（MMU 映射的最小单位 4k ）

7. 对申请的映射区内存，不能越界访问。 

8. munmap用于释放的 地址，必须是mmap申请返回的地址。

9. 映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。

10.  映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。
</code></pre>
<p>mmap函数的保险调用方式：</p>
<pre><code>1. fd = open（&quot;文件名&quot;， O_RDWR）;

2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
</code></pre>
<p>父子进程使用 mmap 进程间通信：</p>
<pre><code>父进程 先 创建映射区。 open（ O_RDWR） mmap( MAP_SHARED );

指定 MAP_SHARED 权限

fork() 创建子进程。

一个进程读， 另外一个进程写。
</code></pre>
<p>无血缘关系进程间 mmap 通信：  				【会写】</p>
<pre><code>两个进程 打开同一个文件，创建映射区。

指定flags 为 MAP_SHARED。

一个进程写入，另外一个进程读出。

【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。

                fifo：数据只能一次读取。
</code></pre>
<p>匿名映射：只能用于 血缘关系进程间通信。</p>
<pre><code>p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
</code></pre>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>信号共性：</p>
<pre><code>简单、不能携带大量信息、满足条件才发送。
</code></pre>
<p>信号的特质：</p>
<pre><code>信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。

所有信号的产生及处理全部都是由【内核】完成的。
</code></pre>
<p>信号相关的概念：</p>
<pre><code>产生信号：

    1. 按键产生

    2. 系统调用产生

    3. 软件条件产生

    4. 硬件异常产生

    5. 命令产生

概念：
    未决：产生与递达之间状态。  

    递达：产生并且送达到进程。直接被内核处理掉。

    信号处理方式： 执行默认处理动作、忽略、捕捉（自定义）


    阻塞信号集（信号屏蔽字）： 本质：位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，在解除屏蔽前，一直处于未决态。

    未决信号集：本质：位图。用来记录信号的处理状态。该信号集中的信号，表示，已经产生，但尚未被处理。
</code></pre>
<p>信号4要素：</p>
<pre><code>信号使用之前，应先确定其4要素，而后再用！！！

编号、名称、对应事件、默认处理动作。
</code></pre>
<p>kill命令 和 kill函数：</p>
<pre><code>int kill（pid_t pid, int signum）

参数：
    pid: 	&gt; 0:发送信号给指定进程

        = 0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。

        &lt; -1: 取绝对值，发送信号给该绝对值所对应的进程组的所有组员。

        = -1：发送信号给，有权限发送的所有进程。

    signum：待发送的信号

返回值：
    成功： 0

    失败： -1 errno
</code></pre>
<p>alarm 函数：使用自然计时法。</p>
<pre><code>定时发送SIGALRM给当前进程。

unsigned int alarm(unsigned int seconds);

    seconds：定时秒数

    返回值：上次定时剩余时间。

        无错误现象。

    alarm（0）； 取消闹钟。

time 命令 ： 查看程序执行时间。   实际时间 = 用户时间 + 内核时间 + 等待时间。  --》 优化瓶颈 IO
</code></pre>
<p>setitimer函数：</p>
<pre><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);

参数：
    which：	ITIMER_REAL： 采用自然计时。 ——&gt; SIGALRM

        ITIMER_VIRTUAL: 采用用户空间计时  ---&gt; SIGVTALRM

        ITIMER_PROF: 采用内核+用户空间计时 ---&gt; SIGPROF
    
    new_value：定时秒数

               类型：struct itimerval &#123;

           				struct timeval &#123;
           					time_t      tv_sec;         /* seconds */
           					suseconds_t tv_usec;        /* microseconds */

       				&#125;it_interval;---&gt; 周期定时秒数

           				 struct timeval &#123;
           					time_t      tv_sec;         
           					suseconds_t tv_usec;        

       				&#125;it_value;  ---&gt; 第一次定时秒数  
       			 &#125;;

    old_value：传出参数，上次定时剩余时间。

    e.g.
        struct itimerval new_t;	
        struct itimerval old_t;	

        new_t.it_interval.tv_sec = 0;
        new_t.it_interval.tv_usec = 0;
        new_t.it_value.tv_sec = 1;
        new_t.it_value.tv_usec = 0;

        int ret = setitimer(&amp;new_t, &amp;old_t);  定时1秒

返回值：
    成功： 0

    失败： -1 errno
</code></pre>
<p>其他几个发信号函数：</p>
<pre><code>int raise(int sig);

void abort(void);
</code></pre>
<p>信号集操作函数：</p>
<pre><code>sigset_t set;  自定义信号集。

sigemptyset(sigset_t *set);	清空信号集

sigfillset(sigset_t *set);	全部置1

sigaddset(sigset_t *set, int signum);	将一个信号添加到集合中

sigdelset(sigset_t *set, int signum);	将一个信号从集合中移除

sigismember（const sigset_t *set，int signum); 判断一个信号是否在集合中。 在--》1， 不在--》0
</code></pre>
<p>设置信号屏蔽字和解除屏蔽：</p>
<pre><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

    how:	SIG_BLOCK:	设置阻塞

        SIG_UNBLOCK:	取消阻塞

        SIG_SETMASK:	用自定义set替换mask。

    set：	自定义set

    oldset：旧有的 mask。
</code></pre>
<p>查看未决信号集：</p>
<pre><code>int sigpending(sigset_t *set);

    set： 传出的 未决信号集。
</code></pre>
<p>【信号捕捉】：</p>
<pre><code>signal();

【sigaction();】 重点！！！
</code></pre>
<p>​		</p>
<p>信号捕捉特性：</p>
<pre><code>1. 捕捉函数执行期间，信号屏蔽字 由 mask --&gt; sa_mask , 捕捉函数执行结束。 恢复回mask

2. 捕捉函数执行期间，本信号自动被屏蔽(sa_flgs = 0).

3. 捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次！
</code></pre>
<p>借助信号完成 子进程回收。</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>守护进程：</p>
<pre><code>daemon进程。通常运行与操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。

不受用户登录注销影响。通常采用以d结尾的命名方式。
</code></pre>
<p>守护进程创建步骤：</p>
<pre><code>1. fork子进程，让父进程终止。

2. 子进程调用 setsid() 创建新会话

3. 通常根据需要，改变工作目录位置 chdir()， 防止目录被卸载。

4. 通常根据需要，重设umask文件权限掩码，影响新文件的创建权限。  022 -- 755	0345 --- 432   r---wx-w-   422

5. 通常根据需要，关闭/重定向 文件描述符

6. 守护进程 业务逻辑。while（）
</code></pre>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>线程概念：</p>
<pre><code>进程：有独立的 进程地址空间。有独立的pcb。	分配资源的最小单位。

线程：有独立的pcb。没有独立的进程地址空间。	最小单位的执行。

ps -Lf 进程id 	---&gt; 线程号。LWP  --》cpu 执行的最小单位。
</code></pre>
<p>线程共享：</p>
<pre><code>独享 栈空间（内核栈、用户栈）

共享 ./text./data ./rodataa ./bsss heap  ---&gt; 共享【全局变量】（errno）
</code></pre>
<p>线程控制原语：</p>
<pre><code>pthread_t pthread_self(void);	获取线程id。 线程id是在进程地址空间内部，用来标识线程身份的id号。

    返回值：本线程id


检查出错返回：  线程中。

    fprintf(stderr, &quot;xxx error: %s\n&quot;, strerror(ret));


int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void *), void *arg); 创建子线程。

    参1：传出参数，表新创建的子线程 id

    参2：线程属性。传NULL表使用默认属性。

    参3：子线程回调函数。创建成功，ptherad_create函数返回时，该函数会被自动调用。
    
    参4：参3的参数。没有的话，传NULL

    返回值：成功：0

        失败：errno


循环创建N个子线程：

    for （i = 0； i &lt; 5; i++）

        pthread_create(&amp;tid, NULL, tfn, (void *)i);   // 将 int 类型 i， 强转成 void *， 传参。	


void pthread_exit(void *retval);  退出当前线程。

    retval：退出值。 无退出值时，NULL

    exit();	退出当前进程。

    return: 返回到调用者那里去。

    pthread_exit(): 退出当前线程。


int pthread_join(pthread_t thread, void **retval);	阻塞 回收线程。

    thread: 待回收的线程id

    retval：传出参数。 回收的那个线程的退出值。

        线程异常借助，值为 -1。

    返回值：成功：0

        失败：errno

int pthread_detach(pthread_t thread);		设置线程分离

    thread: 待分离的线程id
</code></pre>
<p>​	<br>​		返回值：成功：0<br>​	<br>            失败：errno	</p>
<pre><code>int pthread_cancel(pthread_t thread);		杀死一个线程。  需要到达取消点（保存点）

    thread: 待杀死的线程id
    
    返回值：成功：0

        失败：errno

    如果，子线程没有到达取消点， 那么 pthread_cancel 无效。

    我们可以在程序中，手动添加一个取消点。使用 pthread_testcancel();

    成功被 pthread_cancel() 杀死的线程，返回 -1.使用pthead_join 回收。


线程控制原语					进程控制原语


pthread_create()				fork();

pthread_self()					getpid();

pthread_exit()					exit(); 		/ return 

pthread_join()					wait()/waitpid()

pthread_cancel()				kill()

pthread_detach()
</code></pre>
<p>线程属性：</p>
<pre><code>设置分离属性。

pthread_attr_t attr  	创建一个线程属性结构体变量

pthread_attr_init(&amp;attr);	初始化线程属性

pthread_attr_setdetachstate(&amp;attr,  PTHREAD_CREATE_DETACHED);		设置线程属性为 分离态

pthread_create(&amp;tid, &amp;attr, tfn, NULL); 借助修改后的 设置线程属性 创建为分离态的新线程

pthread_attr_destroy(&amp;attr);	销毁线程属性
</code></pre>
<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><p>线程同步：</p>
<pre><code>协同步调，对公共区域数据按序访问。防止数据混乱，产生与时间有关的错误。
</code></pre>
<p>锁的使用：</p>
<pre><code>建议锁！对公共数据进行保护。所有线程【应该】在访问公共数据前先拿锁再访问。但，锁本身不具备强制性。
</code></pre>
<p>使用mutex(互斥量、互斥锁)一般步骤：</p>
<pre><code>pthread_mutex_t 类型。 

1. pthread_mutex_t lock;  创建锁

2  pthread_mutex_init; 初始化		1

3. pthread_mutex_lock;加锁		1--	--&gt; 0

4. 访问共享数据（stdout)		

5. pthrad_mutext_unlock();解锁		0++	--&gt; 1

6. pthead_mutex_destroy；销毁锁


初始化互斥量：

    pthread_mutex_t mutex;

    1. pthread_mutex_init(&amp;mutex, NULL);   			动态初始化。

    2. pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;	静态初始化。

注意事项：

    尽量保证锁的粒度， 越小越好。（访问共享数据前，加锁。访问结束【立即】解锁。）

    互斥锁，本质是结构体。 我们可以看成整数。 初值为 1。（pthread_mutex_init() 函数调用成功。）

    加锁： --操作， 阻塞线程。

    解锁： ++操作， 换醒阻塞在锁上的线程。

    try锁：尝试加锁，成功--。失败，返回。同时设置错误号 EBUSY
</code></pre>
<p>restrict关键字：</p>
<pre><code>用来限定指针变量。被该关键字限定的指针变量所指向的内存操作，必须由本指针完成。
</code></pre>
<p>【死锁】：</p>
<pre><code>是使用锁不恰当导致的现象：

    1. 对一个锁反复lock。

    2. 两个线程，各自持有一把锁，请求另一把。
</code></pre>
<p>读写锁：</p>
<pre><code>锁只有一把。以读方式给数据加锁——读锁。以写方式给数据加锁——写锁。

读共享，写独占。

写锁优先级高。

相较于互斥量而言，当读线程多的时候，提高访问效率

pthread_rwlock_t  rwlock;

pthread_rwlock_init(&amp;rwlock, NULL);

pthread_rwlock_rdlock(&amp;rwlock);		try

pthread_rwlock_wrlock(&amp;rwlock);		try

pthread_rwlock_unlock(&amp;rwlock);

pthread_rwlock_destroy(&amp;rwlock);
</code></pre>
<p>条件变量：</p>
<pre><code>本身不是锁！  但是通常结合锁来使用。 mutex

pthread_cond_t cond;

初始化条件变量：

    1. pthread_cond_init(&amp;cond, NULL);   			动态初始化。

    2. pthread_cond_t cond = PTHREAD_COND_INITIALIZER;	静态初始化。

阻塞等待条件：

    pthread_cond_wait(&amp;cond, &amp;mutex);

    作用：	1） 阻塞等待条件变量满足

        2） 解锁已经加锁成功的信号量 （相当于 pthread_mutex_unlock(&amp;mutex)）

        3)  当条件满足，函数返回时，重新加锁信号量 （相当于， pthread_mutex_lock(&amp;mutex);）


pthread_cond_signal(): 唤醒阻塞在条件变量上的 (至少)一个线程。

pthread_cond_broadcast()： 唤醒阻塞在条件变量上的 所有线程。


【要求，能够借助条件变量，完成生成者消费者】
</code></pre>
<p>信号量： </p>
<pre><code>应用于线程、进程间同步。

相当于 初始化值为 N 的互斥量。  N值，表示可以同时访问共享数据区的线程数。

函数：
    sem_t sem;	定义类型。

    int sem_init(sem_t *sem, int pshared, unsigned int value);

    参数：
        sem： 信号量 

        pshared：	0： 用于线程间同步
                
                1： 用于进程间同步

        value：N值。（指定同时访问的线程数）


    sem_destroy();

    sem_wait();		一次调用，做一次-- 操作， 当信号量的值为 0 时，再次 -- 就会阻塞。 （对比 pthread_mutex_lock）

    sem_post();		一次调用，做一次++ 操作. 当信号量的值为 N 时, 再次 ++ 就会阻塞。（对比 pthread_mutex_unlock）
</code></pre>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程</a></div><div class="post_share"><div class="social-share" data-image="/../img/Cbase.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/03/Linux%E5%AE%89%E8%A3%85/"><img class="prev-cover" src="/img/index.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux安装</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/24/%E7%BE%8E%E5%9B%BD%E5%95%86%E4%B8%9A%E5%A4%A7%E4%BA%A8%E4%BC%A0%E5%A5%87/"><img class="next-cover" src="/img/index.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">美国商业大亨传奇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">呆小呆</div><div class="author-info__description">遇见即是上上签</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mlxlbj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://githubfast.com/mlxlbj" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2099774656@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">第一章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">第二章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">第三章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">第四章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-number">5.</span> <span class="toc-text">第五章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="toc-number">6.</span> <span class="toc-text">第六章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">第七章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">第八章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0"><span class="toc-number">9.</span> <span class="toc-text">第九章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0"><span class="toc-number">10.</span> <span class="toc-text">第十章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/05/%E7%B2%89%E4%BD%93%E8%BE%93%E9%80%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="粉体输送系统设计"><img src="/img/index.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="粉体输送系统设计"/></a><div class="content"><a class="title" href="/2023/01/05/%E7%B2%89%E4%BD%93%E8%BE%93%E9%80%81%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="粉体输送系统设计">粉体输送系统设计</a><time datetime="2023-01-05T12:45:35.000Z" title="发表于 2023-01-05 20:45:35">2023-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/15/%E9%9D%9E%E6%A0%87%E8%AE%BE%E8%AE%A1/" title="非标设计"><img src="/img/index.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="非标设计"/></a><div class="content"><a class="title" href="/2022/10/15/%E9%9D%9E%E6%A0%87%E8%AE%BE%E8%AE%A1/" title="非标设计">非标设计</a><time datetime="2022-10-15T03:59:04.000Z" title="发表于 2022-10-15 11:59:04">2022-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/28/%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="软件快捷键"><img src="/img/index.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件快捷键"/></a><div class="content"><a class="title" href="/2022/09/28/%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="软件快捷键">软件快捷键</a><time datetime="2022-09-28T14:13:13.000Z" title="发表于 2022-09-28 22:13:13">2022-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/03/Linux%E5%AE%89%E8%A3%85/" title="Linux安装"><img src="/img/index.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux安装"/></a><div class="content"><a class="title" href="/2022/09/03/Linux%E5%AE%89%E8%A3%85/" title="Linux安装">Linux安装</a><time datetime="2022-09-03T02:55:33.000Z" title="发表于 2022-09-03 10:55:33">2022-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/29/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程"><img src="/../img/Cbase.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程"/></a><div class="content"><a class="title" href="/2022/08/29/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" title="Linux系统编程">Linux系统编程</a><time datetime="2022-08-29T11:22:03.000Z" title="发表于 2022-08-29 19:22:03">2022-08-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../img/Cbase.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 呆小呆</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="35px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>